package instanceSelection.lshis

import java.util.Arrays
import java.util.Random

import org.apache.spark.mllib.linalg.Vector
import org.apache.spark.mllib.regression.LabeledPoint

/**
 * Table of hash functions that assign the same bucket to similar instances.
 * Its performing is supported on locality sensitive hashing (LSH).
 *
 * @param  numOfANDs Number of hash functions combined by AND operator.
 * @param  dim   Size of the hash functions. It also corresponds with the number
 *               of attributes of the instance.
 * @param  width Width of each bucket.
 * @param  seed  Seed for random generator.
 *
 * @author Alejandro González Rogel
 * @author Álvar Arnaiz-González
 * @version 1.2.0
 */
@SerialVersionUID(1L)
class ANDsTable(numOfANDs: Int,
                dim: Int,
                width: Double,
                seed: Long) extends Serializable {

  // Random generator for hashes.
  val rand = new Random(seed)

  // Create EuclideanHash elements
  val ands = for { i <- 0 until numOfANDs }
    yield new EuclideanHash(dim, width, rand.nextLong())

  /**
   *
   * Hash function based on the Euclidean distance between elements.
   *
   * @param  dim  Dimensionality of the input vector.
   * @param  width  Bucket width
   * @param  seed  Seed
   *
   * @constructor Computes a new random vector and a displacement vector (also random).
   * 
   * @author Alejandro González Rogel
   * @author Álvar Arnaiz-González
   * @version 1.2.0
   */
  @SerialVersionUID(1L)
  class EuclideanHash(dim: Int,
                      width: Double,
                      seed: Long) extends Serializable {

    /**
     * Random generator.
     */
    private val rand = new Random(seed)

    /**
     * Displacement vector for calculating the hash.
     */
    private val offset = {
      if (width < 1.0) {
        rand.nextInt((width * 10).toInt) / 10.0
      } else {
        rand.nextInt(width.toInt)
      }
    }

    /**
     * Random vector.
     */
    val randomProjection = for { i <- 0 until dim } yield rand.nextGaussian()

    /**
     * Computes an integer after given a vector to the hash function.
     *
     * @param attr  Vector with the attribute values of an instance.
     *   This includes the class attribute
     */
    def hash(attr: Array[Double]): Int = {
      var sum = 0.0;

      for { i <- 0 until attr.size } {
        sum += (randomProjection(i) * attr(i))
      }

      var result = (sum + offset) / width

      result.round.toInt
    }

  }

  /**
   *
   * Computes the hash value of an instance.
   *
   * The computed value is the result of feeding the instance vector to all
   * the hash functions and, then, feed the results to a different hash function. 
   *
   * @param  int  Instance
   * @param Hash value generated by the vector.
   */
  def hash(inst: LabeledPoint): Int = {
    hash(inst.features.toArray)
  }

  /**
   * Computes the hash value for an instance.
   *
   * Generates a value by passing the instance through the whole set of
   * hash functions and combine all of them.
   *
   * @param  inst  Instance to hash.
   * @return hash value (bucket).
   */
  def hash(inst: Vector): Int = {
    hash(inst.toArray)
  }

  /**
   * Computes the hash value for an array of doubles.
   *
   * Generates a hash value by passing the array through the whole set of
   * hash functions and, finally, it combines all of them.
   *
   * @param  attr  Array of doubles to hash.
   * @return hash value (bucket).
   */
  def hash(attr: Array[Double]): Int = {

    // Compute the hash value of every single hash function.
    val hashValues = for { i <- 0 until ands.size }
      yield ands(i).hash(attr)

    // Finally all of hash values are combined to return a final hash code.
    Arrays.hashCode(hashValues.toArray)
  }

}
